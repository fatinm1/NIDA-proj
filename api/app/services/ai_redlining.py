import os
import json
import logging
from typing import List, Dict, Any, Optional
from openai import OpenAI
from docx import Document as DocxDocument
from docx.shared import Inches
from docx.enum.text import WD_COLOR_INDEX
from docx.oxml.shared import OxmlElement, qn
from datetime import datetime

logger = logging.getLogger(__name__)

class AIRedliningService:
    def __init__(self):
        try:
            api_key = os.getenv('OPENAI_API_KEY')
            if not api_key or api_key == 'mock-key-for-development':
                # Use mock mode for development
                self.client = None
                self.model = "mock-gpt-4"
                logger.info("Running in mock mode - no OpenAI API calls will be made")
            else:
                self.client = OpenAI(api_key=api_key)
                self.model = "gpt-4"
                logger.info("OpenAI client initialized successfully")
        except Exception as e:
            logger.error(f"Error initializing OpenAI client: {str(e)}")
            self.client = None
            self.model = "mock-gpt-4"
            logger.info("Falling back to mock mode")
        
    def analyze_document(self, document_text: str, custom_rules: List[Dict[str, Any]]) -> Dict[str, Any]:
        """
        Analyze the document using OpenAI GPT-4 and return redlining instructions
        """
        try:
            # Check if we're in mock mode
            if not self.client:
                return self._mock_analysis(document_text, custom_rules)
            
            # Prepare the prompt for GPT-4
            system_prompt = self._build_system_prompt(custom_rules)
            user_prompt = self._build_user_prompt(document_text, custom_rules)
            
            response = self.client.chat.completions.create(
                model=self.model,
                messages=[
                    {"role": "system", "content": system_prompt},
                    {"role": "user", "content": user_prompt}
                ],
                temperature=0.1,  # Low temperature for consistent legal work
                max_tokens=4000
            )
            
            # Parse the AI response
            ai_response = response.choices[0].message.content
            redlining_instructions = self._parse_ai_response(ai_response)
            
            return {
                'success': True,
                'redlining_instructions': redlining_instructions,
                'ai_analysis': ai_response
            }
            
        except Exception as e:
            logger.error(f"Error in AI analysis: {str(e)}")
            return {
                'success': False,
                'error': str(e)
            }
    
    def _mock_analysis(self, document_text: str, custom_rules: List[Dict[str, Any]]) -> Dict[str, Any]:
        """Provide mock analysis for development/testing"""
        logger.info("Running mock AI analysis")
        
        # Create mock redlining instructions based on custom rules
        mock_modifications = []
        for rule in custom_rules:
            mock_modifications.append({
                "type": "TEXT_REPLACE",
                "section": rule.get('category', 'general'),
                "current_text": "existing text",
                "new_text": f"modified text based on: {rule['instruction']}",
                "reason": rule['instruction'],
                "location_hint": "Mock location"
            })
        
        return {
            'success': True,
            'redlining_instructions': {
                'modifications': mock_modifications,
                'summary': f"Mock analysis completed with {len(mock_modifications)} modifications",
                'risk_assessment': "Mock assessment - no actual legal analysis performed"
            },
            'ai_analysis': "This is a mock AI analysis for development purposes. In production, this would be generated by OpenAI GPT-4."
        }
    
    def _build_system_prompt(self, custom_rules: List[Dict[str, Any]]) -> str:
        """Build the system prompt for GPT-4"""
        base_prompt = """You are an expert legal AI assistant specializing in NDA (Non-Disclosure Agreement) redlining. 
        Your task is to analyze NDA documents and provide specific, actionable redlining instructions.
        
        You must:
        1. Identify areas that need modification based on the provided rules
        2. Provide specific text changes with clear before/after examples
        3. Ensure all modifications maintain legal validity
        4. Focus on confidentiality terms, party definitions, liability clauses, and firm details
        5. Return your response in a structured JSON format
        
        Available modification types:
        - TEXT_REPLACE: Replace specific text
        - TEXT_INSERT: Insert new text at specific locations
        - TEXT_DELETE: Remove specific text
        - CLAUSE_ADD: Add entire new clauses
        - TERM_MODIFY: Modify time-based terms
        - PARTY_ADD: Add new parties to definitions
        
        Return your analysis in this exact JSON format:
        {
            "modifications": [
                {
                    "type": "TEXT_REPLACE",
                    "section": "confidentiality_term",
                    "current_text": "5 years",
                    "new_text": "2 years",
                    "reason": "Term exceeds maximum allowed duration",
                    "location_hint": "Section 3.1, line 15"
                }
            ],
            "summary": "Brief summary of all changes",
            "risk_assessment": "Assessment of any legal risks in modifications"
        }"""
        
        if custom_rules:
            rules_text = "\n\nCustom Rules to Apply:\n"
            for rule in custom_rules:
                rules_text += f"- {rule['instruction']}\n"
            base_prompt += rules_text
        
        return base_prompt
    
    def _build_user_prompt(self, document_text: str, custom_rules: List[Dict[str, Any]]) -> str:
        """Build the user prompt with document content"""
        prompt = f"""Please analyze the following NDA document and provide redlining instructions based on the custom rules.
        
        Document Content:
        {document_text[:8000]}  # Limit to first 8000 chars to stay within token limits
        
        Please provide your analysis in the specified JSON format."""
        
        return prompt
    
    def _parse_ai_response(self, ai_response: str) -> List[Dict[str, Any]]:
        """Parse the AI response and extract redlining instructions"""
        try:
            # Try to extract JSON from the response
            if '{' in ai_response and '}' in ai_response:
                start = ai_response.find('{')
                end = ai_response.rfind('}') + 1
                json_str = ai_response[start:end]
                
                parsed = json.loads(json_str)
                return parsed.get('modifications', [])
            else:
                logger.warning("Could not parse AI response as JSON")
                return []
                
        except json.JSONDecodeError as e:
            logger.error(f"JSON parsing error: {str(e)}")
            return []
        except Exception as e:
            logger.error(f"Error parsing AI response: {str(e)}")
            return []

class DocumentProcessor:
    def __init__(self, ai_service: AIRedliningService):
        self.ai_service = ai_service
    
    def process_document(self, doc_path: str, custom_rules: List[Dict[str, Any]], 
                        firm_details: Dict[str, Any]) -> Dict[str, Any]:
        """
        Process a Word document with AI redlining and return the modified document
        """
        try:
            # Load the document
            doc = DocxDocument(doc_path)
            
            # Extract text for AI analysis
            document_text = self._extract_document_text(doc)
            
            # Get AI redlining instructions
            ai_result = self.ai_service.analyze_document(document_text, custom_rules)
            
            if not ai_result['success']:
                return {
                    'success': False,
                    'error': ai_result['error']
                }
            
            # Apply AI modifications
            modifications = ai_result['redlining_instructions']
            self._apply_modifications(doc, modifications)
            
            # Apply firm details
            self._apply_firm_details(doc, firm_details)
            
            # Generate output path
            output_path = self._generate_output_path(doc_path)
            
            # Save the modified document
            doc.save(output_path)
            
            return {
                'success': True,
                'output_path': output_path,
                'modifications_applied': len(modifications),
                'ai_analysis': ai_result['ai_analysis']
            }
            
        except Exception as e:
            logger.error(f"Error processing document: {str(e)}")
            return {
                'success': False,
                'error': str(e)
            }
    
    def _extract_document_text(self, doc: DocxDocument) -> str:
        """Extract text content from the Word document"""
        text_parts = []
        for paragraph in doc.paragraphs:
            text_parts.append(paragraph.text)
        
        return '\n'.join(text_parts)
    
    def _apply_modifications(self, doc: DocxDocument, modifications: List[Dict[str, Any]]):
        """Apply AI-generated modifications to the document"""
        for mod in modifications:
            try:
                if mod['type'] == 'TEXT_REPLACE':
                    self._replace_text(doc, mod['current_text'], mod['new_text'])
                elif mod['type'] == 'TEXT_INSERT':
                    self._insert_text(doc, mod['new_text'], mod.get('location_hint', ''))
                elif mod['type'] == 'TEXT_DELETE':
                    self._delete_text(doc, mod['current_text'])
                elif mod['type'] == 'CLAUSE_ADD':
                    self._add_clause(doc, mod['new_text'])
                    
            except Exception as e:
                logger.warning(f"Failed to apply modification {mod}: {str(e)}")
                continue
    
    def _replace_text(self, doc: DocxDocument, old_text: str, new_text: str):
        """Replace text in the document with tracked changes"""
        for paragraph in doc.paragraphs:
            if old_text in paragraph.text:
                # Create tracked change
                paragraph.text = paragraph.text.replace(old_text, new_text)
                # Add redlining formatting
                for run in paragraph.runs:
                    if new_text in run.text:
                        run.font.color.rgb = None  # Reset color
                        run.font.highlight_color = WD_COLOR_INDEX.YELLOW
    
    def _insert_text(self, doc: DocxDocument, text: str, location_hint: str):
        """Insert new text at specified location"""
        # Find appropriate location and insert
        new_paragraph = doc.add_paragraph(text)
        new_paragraph.runs[0].font.highlight_color = WD_COLOR_INDEX.GREEN
    
    def _delete_text(self, doc: DocxDocument, text: str):
        """Delete text from the document"""
        for paragraph in doc.paragraphs:
            if text in paragraph.text:
                paragraph.text = paragraph.text.replace(text, '')
                # Add strikethrough formatting for deleted text
                for run in paragraph.runs:
                    run.font.strike = True
    
    def _add_clause(self, doc: DocxDocument, clause_text: str):
        """Add a new clause to the document"""
        new_paragraph = doc.add_paragraph(clause_text)
        new_paragraph.runs[0].font.highlight_color = WD_COLOR_INDEX.GREEN
    
    def _apply_firm_details(self, doc: DocxDocument, firm_details: Dict[str, Any]):
        """Apply firm details to signature blocks and firm information"""
        # Find and replace placeholder text with firm details
        for paragraph in doc.paragraphs:
            if '[FIRM_NAME]' in paragraph.text:
                paragraph.text = paragraph.text.replace('[FIRM_NAME]', firm_details.get('name', ''))
            if '[FIRM_ADDRESS]' in paragraph.text:
                paragraph.text = paragraph.text.replace('[FIRM_ADDRESS]', firm_details.get('address', ''))
            if '[SIGNER_NAME]' in paragraph.text:
                paragraph.text = paragraph.text.replace('[SIGNER_NAME]', firm_details.get('signerName', ''))
            if '[SIGNER_TITLE]' in paragraph.text:
                paragraph.text = paragraph.text.replace('[SIGNER_TITLE]', firm_details.get('signerTitle', ''))
    
    def _generate_output_path(self, input_path: str) -> str:
        """Generate output path for the processed document"""
        # Get the absolute path to the uploads directory
        base_dir = os.path.abspath('uploads')
        filename = os.path.basename(input_path)
        name, ext = os.path.splitext(filename)
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        output_filename = f"{name}_redlined_{timestamp}{ext}"
        return os.path.join(base_dir, output_filename)
